const US_REGIONS = ["us", "enhanced_us"];

export function getReproducibilityCodeBlock(metadata, policy, region, type) {

  /*
  if (!policy.reform || !policy.reform.data) {
    console.error("getReproducibilityCodeBlock: policy parameter is malformed");
    return;
  }
  */

  // Return a series of lines, concatted into an array, 
  // generated by sub-functions

  return [
    ...getHeaderCode(metadata, policy, type),
    ...getBaselineCode(policy, region, type),
    ...getReformCode(policy, region),
    /*
    ...getSituationCode(),
    ...getImplementationCode()
    */
  ];

}

function getHeaderCode(metadata, policy, type) {

  let lines = [];

  // Add lines depending upon type of block
  if (type === "household") {
    lines.push("from " + metadata.package + " import Simulation");
  } else {
    lines.push("from " + metadata.package + " import Microsimulation");
  }

  // If there is a reform, add the following Python imports
  if (Object.keys(policy.reform.data).length > 0) {
    lines.push(
      "from policyengine_core.reforms import Reform",
      "from policyengine_core.periods import instant",
    );
  }

  return lines;

}

export function getBaselineCode(policy, region, type) {
  console.log(policy);
  console.log(region);
  console.log(type);

  console.log(Object.keys(policy.reform.data));

  // Disregard baseline code for household code
  // that doesn't contain a reform
  if (
    type === "household" &&
    Object.keys(policy.reform.data).length <= 0
  ) {
    return [];
  }

  // Disregard baseline code for non-US
  // locales
  if (!US_REGIONS.includes(region)) {
    return [];
  }

  // Calculate the earliest start date and latest end date for
  // the policies included in the simulation
  const {earliestStart, latestEnd} = getStartEndDates(policy);

  return [
    "",
    "",
    `"""`,
    "In US nationwide simulations,",
    "use reported state income tax liabilities",
    `"""`,
    "def modify_baseline(parameters):",
    "    parameters.simulation.reported_state_income_tax.update(",
    `        start=instant("${earliestStart}"), stop=instant("${latestEnd}"),`,
    "        value=True)",
    "    return parameters",
    "",
    "",
    "class baseline_reform(Reform):",
    "    def apply(self):",
    "        self.modify_parameters(modify_baseline)",
  ];

}

export function getReformCode(policy, region) {

  // Return no reform code for households or policies
  // without reform parameters
  if (Object.keys(policy.reform.data).length <= 0) {
    return [];
  }

  let lines = [
    "",
    "",
    "def modify_parameters(parameters):",
  ];

  if (US_REGIONS.includes(region)) {
    // Calculate the earliest start date and latest end date for
    // the policies included in the simulation
    const {earliestStart, latestEnd} = getStartEndDates(policy);

    lines.push(
      "    parameters.simulation.reported_state_income_tax.update(",
      `        start=instant("${earliestStart}"), stop=instant("${latestEnd}"),`,
      "        value=True)",
    );
  }

  for (const [parameterName, parameter] of Object.entries(policy.reform.data)) {
    for (let [instant, value] of Object.entries(parameter)) {
      const [start, end] = instant.split(".");
      if (value === false) {
        value = "False";
      } else if (value === true) {
        value = "True";
      }
      lines.push(
        `    parameters.${parameterName}.update(`,
        `        start=instant("${start}"), stop=instant("${end}"),`,
        `        value=${value})`,
      );
    }
  }
  lines.push("    return parameters");

  lines = lines.concat([
    "",
    "",
    "class reform(Reform):",
    "    def apply(self):",
    "        self.modify_parameters(modify_parameters)",
    "",
    "",
  ]);
  return lines;

}

export function getStartEndDates(policy) {

  let earliestStart = null;
  let latestEnd = null;

  for (const parameter of Object.keys(policy.reform.data)) {
    for (const instant of Object.keys(policy.reform.data[parameter])) {
      const [start, end] = instant.split(".");
      if (!earliestStart || Date.parse(start) < Date.parse(earliestStart)) {
        earliestStart = start;
      }
      if (!latestEnd || Date.parse(end) > Date.parse(latestEnd)) {
        latestEnd = end;
      }
    }
  }

  return ({
    earliestStart: earliestStart,
    latestEnd: latestEnd
  });
}

export function getReformDefinitionCode(metadata, policy) {
  let lines = [
    "from policyengine_core.reforms import Reform",
    "from policyengine_core.periods import instant",
    "import pandas as pd",
    "",
    "",
    "def modify_parameters(parameters):",
  ];

  if (Object.keys(policy.reform.data).length === 0) {
    lines.pop();
    return lines;
  }

  for (const [parameterName, parameter] of Object.entries(policy.reform.data)) {
    for (let [instant, value] of Object.entries(parameter)) {
      const [start, end] = instant.split(".");
      if (value === false) {
        value = "False";
      } else if (value === true) {
        value = "True";
      }
      lines.push(
        `    parameters.${parameterName}.update(`,
        `        start=instant("${start}"), stop=instant("${end}"),`,
        `        value=${value})`,
      );
    }
  }
  lines.push("    return parameters");

  lines = lines.concat([
    "",
    "",
    "class reform(Reform):",
    "    def apply(self):",
    "        self.modify_parameters(modify_parameters)",
    "",
    "",
  ]);
  return lines;
}
